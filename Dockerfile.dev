FROM node:16-alpine


#------------------------------------------------------------------------------------------------------------------------

# < USER node >

# - 도커 이미지(또는 컨테이너) Dockerfile에 실행되는 명령어를 수행하는 사용자를 'node'로 설정하여, 
#   이후 모든 후속 명령은 'node 사용자'로 실행되도록 지시하는 것.
# - 애플리케이션의 보안 강화를 위해 root 대신 일반 사용자로 실행하여, 애플리케이션의 보안성을 증가시키며, 사용자 접근을 컨트롤함.
#   명시적으로 사용자를 설정하여, owner를 통제할 수 있고, 애플리케이션과의 경계를 명확하게 함.


USER node

#------------------------------------------------------------------------------------------------------------------------

# < RUN mkdir -p /homoe/node/app >

# - 도커 이미지(또는 컨테이너) 내부에서 디렉토리 생성이 필요한 경우 사용함.
#   '폴더(디렉토리) /home/node/app'가 있는지 확인하고, 만약 없는 경우 이 폴더를 생성함.
# - 애플리케이션의 코드와 종속성을 저장하는 공간.
# - '-p 옵션': 해당 경로가 없는 경우에 그 디렉토리를 생성해버림.

RUN mkdir -p /home/node/app


#------------------------------------------------------------------------------------------------------------------------


# < WORKDIR /usr/app >

# - 사용법: WORKDIR [path]
# - 'path'에 지정된 경로를 이제 그 컨테이너의 '작업 디렉토리'로 설정함. 
#   이 때, 기존의 경로가 이미 존재하지 않으면, 새로운 작업 디렉토리를 생성됨.
#   이미 지정된 경로가 있다면, 해당 경로를 작업 디렉토리로 사용함.
# - WORKDIR은 이후 Dockerfile에서 실행되는 COPY, RUN, CMD, ENTRYPOINT, ADD등의 명령어들이 실행되는 '기본 작업 디렉토리'를 설정하는
#   기능임.
# - 현재 컨테이너의 '작업 디렉토리'를 '/home/node/app'으로 설정하는 명령어.
#   이후의 명령어에서 '기준 경로'로 사용됨.  
#   '기준 경로'가 되기 때문에 저 아래의 'COPY 명령어'에서 두 번째 './'가 바로 여기서 만든 '작업 디렉토리'가 됨.

WORKDIR /home/node/app


#------------------------------------------------------------------------------------------------------------------------


# < COPY --chown=node:node ./package.json ./ >

# - 내 로컬 컴퓨터(=호스트 머신)에 있는 package.json 파일(종속성 목록 담은 파일)을 
#   도커 이미지(정확히는, 도커 컨테이너 내부의 작업 디렉토리)로 복사 추가하고(즉, 의존성 복사가 목적임),
#   pakcage.json 파일의 소유권을 현재 설정된 사용자(node)로 지정함.
# '--chown=node:node': COPY 명령어를 사용하여 파일(여기서는 package.json 파일)을 복사할 때, 
#                      package.json 파일 복사 후의 pakcage.json 파일의 '소유자'와 '그룹 소유자'를 지정하는 옵션.
#                      이는 package.json 파일에 외부 사용자(또는 프로세스)가 접근하는 것을 제한하고 보안을 강화하기 위함임.
# './package.json': 로컬 작업 디렉토리의 package.json 파일을 선택. package.json 파일은 Node.js 애플리케이션에서 필요한 의존성과
#                   스크립트 정보를 가지고 있음.
# './ 이하 경로': COPY 명령에서 복사될 파일의 목적지 위치(=컨테이너 내부에서의 위치). 
#                도커 이미지에서의 현재 작업 디렉토리(여기서는 /home/node/app, 즉 app 디렉토리를 기준으로 함)로
#                 package.json 파일을 복사하는 것임.       
# '.': '현재 디렉토리'를 의미함.            

# 이전 프로젝트의 'COPY ./package.json ./'은, pakcage.json 파일의 소유권을 변경하지 않고 복사 추가하고,
# 현재 프로젝트의 'COPY --chowon=node:node ./package.json ./'은, 이제 복사된 pakcage.josn 파일의 소유자 및 그룹을 node로 지정하여 
# 복사 추가하는 것임.


COPY --chown=node:node ./package.json ./


#------------------------------------------------------------------------------------------------------------------------


# < RUN npm install >

# - RUN 명령으로 npm(Node Package Manager)을 설치하고, package.json 파일 내부에 있는 의존성들을을 설치함. 
#   도커 이미지 내부에 의존성들이 설치되면, 이 도커 이미지를 사용하는 모든 컨테이너에서 동일한 의존성 버전들을 공유할 수 있음.

# - wsl에서 'npm install이 내장되어 포함된 node:14-alpine'을 가져와서 이 Dockerfile을 빌드할 때(=docker build .), 
#   Dockerfile 이외의 파일들, 즉 여기서는 'package.json'과 'index.js'과 같은 파일들은 기본값으로 같이 빌드되어 
#   컨테이너 안으로 들어가지 않음!
#   따라서, 'npm install 명령어'를 실행하여 Node Package Modules(Manager)을 설치하고, 이를 통해 package.json 내부의 의존성 목록들을 
#   읽어오고,
#   해당 모듈들(의존성이 설치된 모듈들)을 Node.js 애플리케이션에서 사용할 수 있도록(=컨테이너 내부로 불러들일 수 있도록) 컨테이너 내부에 
#   설치함. 이 단계에서 필요한 라이브러리 등이 도커 이미지에 포함됨.

# - 여기서는, 위에서 현재 컨테이너 이미지 빌드의 작업 디렉토리에 포함(복사)시킨 'package.json' 파일에 포함된 의존성을 설치시키기 위해
#   npm install 명령어를 실행시킴.
#   이렇게 함으로써, Node.js 애플리케이션에 필요한 모듈을 컨테이너에 설치할 수 있음.
#   (=애플리케이션 실행에 필요한 라이브러리와 패키지를 도커 이미지에 추가하는 것임.)
# - 즉, npm install은 package.json의 의존성 설치만을 담당하고 있는 것이다! 
#   npm install은 기타 index.js 와 같은 파일과는 아무런 영향을 서로 주고받지 않는다!


RUN npm install


#------------------------------------------------------------------------------------------------------------------------


# < COPY --chown=node:node ./ ./ >

# - 저 위에서 'COPY --chown=node:node ./package.json ./'를 먼저 실행하여 모든 의존성을 컨테이너 내부로 복사 추가하여 설치한 후,
#   이제 남은 프로젝트 파일들을 이번에도 COPY 명령으로 복사한다.
#   이렇게 해서 비로서 애플리케이션 구성 요소들이 완전히 다 추가되어 도커 이미지가 완성되게 되는 것임.
# - Dockerfile을 파싱 시, Docker 빌드 환경은 '명령어 COPY'를 만나면 이를 처리함.
#   처리 과정에서 원본 경로의 파일과 디렉토리를, 대상 경로에 복사하고 새 도커 이미지 레이어에 기록함.
#   이를 통해 필요한 파일들이 도커 이미지에 포함되어 빌드됨.
# - 여기서는, '현재 내 로컬 컴퓨터 호스트 디렉토리의 모든 파일과 폴더(= 첫 번째 './')'를 
#   '도커 컨테이너 내부의 작업 디렉토리(= (여기서는 /home/node/app, 즉 app 디렉토리)'로 복사한다!!! 라는 의미임.
# - 형식: COPY ['내 로컬머신에서'의 복사'할'파일, 디렉토리의 경로] ['컨테이너' 내부에서의 그 복사된 파일, 디렉토리가 붙여넣기 될 경로]
# - e.g)
#   ~ COPY app.js /app: '현재 내 로컬 컴퓨터의 디렉토리에 있는 파일 app.js'를 '도커 이미지의 경로 /app'에 복사 붙여넣기 한다.
#   ~ COPY ./src /app/src: 내 로컬 컴퓨터의 해당 폴더의 디렉토리를 전체 복사해서 도커 이미지의 경로 /app/src에 복사 붙여넣기 한다.
#   ~ COPY pakckage.json /app: 외부 종속성을 복사 붙여넣기

# *****중요*****
# - 저 위에서 먼저 'COPY ./package.json'을 실행시켜서, 애플리케이션 실행에 필요한 의존성을 먼저 컨테이너에 따라 포함시켰기 때문에,
#   지금 여기 단계에서의 'COPY ./ ./'는, 이제 'package.json'을 제외한 기존의 어떠한 구 Dockerfile의 내부 코드들을 수정한
#   내 로컬 컴퓨터 디렉토리에 남아있는 파일(소스코드를 담고 있는 'index.js' 등)과 폴더들을 여기서 도커 이미지의 작업 디렉토리로 복사시킴.
#   그리고, 이후 나중에 터미널에서 이 도커 이미지를 빌드할 때, 이 계층만 따로 빌드하는 것임.


COPY --chown=node:node ./ ./



#----------------------------------------------------=====-------------------------------------------------------------------


# < CMD ["npm", "start"] >

# - 도커 컨테이너가 시작될 때마다 기본적으로 'npm start'를 실행시켜주는 명령어.
# - 이 명령어가 실행되면, 애플리케이션이 시작됨. 즉, 이 명령어를 통해 이 애플리케이션에서 필요한 서버가 실행됨.


CMD ["npm", "start"]
